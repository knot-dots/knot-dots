# Indikatoren-Funktionalit√§t Analyse

**Erstellt:** 2025-08-13  
**Kontext:** Plattform-Audit zur Funktionsweise der Indikatoren  
**Basis:** Codebase-Analyse und Meeting-Notizen

## üéØ √úberblick

Indikatoren bilden ein zentrales Element der knot-dots Plattform zur Messung und Steuerung von Nachhaltigkeitsma√ünahmen. Sie verkn√ºpfen Ist-Daten mit Zielvorgaben und erm√∂glichen die Bewertung von Ma√ünahmenwirkungen.

### Kernfunktionen
- **Kennzahlen-Management**: Verwaltung von KPIs mit Basisdaten und Zielwerten
- **Wirkungsmessung**: Verkn√ºpfung von Ma√ünahmen mit messbaren Ergebnissen  
- **Zielverfolgung**: Monitoring von gew√ºnschter Entwicklung vs. Ist-Stand
- **Visualisierung**: Charts und Tabellen f√ºr Datenanalyse

## üèóÔ∏è Datenmodell & Architektur

### Container-basierte Struktur
```typescript
// Indikator als Container-Typ
const indicatorPayload = basePayload.extend({
  historicalValues: z.array(z.tuple([z.number().int().positive(), z.number()])).default([]),
  indicatorCategory: z.array(indicatorCategories).default([]),
  indicatorType: z.array(indicatorTypes).default([]),
  measureType: z.array(measureTypes).default([]),
  quantity: z.string(),
  type: z.literal(payloadTypes.enum.indicator),
  unit: z.string()
});
```

### Indikator-Eigenschaften
**Basisdaten:**
- `title`: Bezeichnung des Indikators
- `description`: Detaillierte Beschreibung
- `quantity`: Art der Messung (CO2, Energie, etc.)
- `unit`: Ma√üeinheit (kg, kWh, %, etc.)

**Kategorisierung:**
- `indicatorType`: Impact, Key, Performance
- `indicatorCategory`: KPI, MPSC, SDG, Custom
- `measureType`: Technische Klassifikation
- `topic`: Themenfelder (Mobilit√§t, Energie, etc.)
- `category`: SDG-Zuordnung

**Zeitreihendaten:**
- `historicalValues`: Array von [Jahr, Wert]-Tupeln f√ºr Ist-Daten

### Beziehungsmodell
```typescript
// Zentrale Relationen f√ºr Indikatoren
predicates = [
  'is-measured-by',      // Ziel ‚Üí Indikator
  'is-objective-for',    // Zielwert ‚Üí Indikator  
  'contributes-to',      // Ma√ünahme ‚Üí Indikator
]
```

## üéõÔ∏è Benutzeroberfl√§che & Komponenten

### Haupt-Komponenten

#### 1. EditableIndicatorDetailView
- **Zweck**: Vollst√§ndige Indikator-Ansicht mit Bearbeitung
- **Features**: 
  - Tab-Navigation (Alle, Ziele, Ma√ünahmen)
  - Umschaltung Chart/Tabelle
  - Verkn√ºpfte Container anzeigen
  - Historische Werte bearbeiten

#### 2. IndicatorChart 
- **Zweck**: Visualisierung von Zeitreihen und Prognosen
- **Features**:
  - Observable Plot-basierte Charts
  - Trend-Linie aus historischen Daten
  - Zielwerte als separate Linie
  - Ma√ünahmenwirkungen als gestapelte Bereiche
  - Status-basierte Farbcodierung

#### 3. IndicatorProperties
- **Zweck**: Metadaten-Verwaltung
- **Features**:
  - Indikator-Typ, Einheit, Kategorie
  - SDG- und Themen-Zuordnung
  - Sichtbarkeit und Berechtigungen
  - Organisationseinheit-Zuordnung

#### 4. IndicatorsOverlay
- **Zweck**: √úbersichts-Dashboard aller Indikatoren
- **Features**:
  - Facettierte Suche und Filter
  - Kategorisierung nach Typ/Thema
  - Kachel-Ansicht der Indikatoren

### Navigation & Workflow
```mermaid
graph TD
    A[Indicators Dashboard] --> B[Indikator ausw√§hlen]
    B --> C[Detail-Ansicht]
    C --> D[Chart/Tabelle]
    C --> E[Verkn√ºpfte Ziele]
    C --> F[Verkn√ºpfte Ma√ünahmen]
    E --> G[Zielwerte bearbeiten]
    F --> H[Wirkungen erfassen]
```

## üîó Verkn√ºpfungslogik

### Indikator ‚Üî Ziele
**Relation**: `is-measured-by`
```typescript
// Ziel wird durch Indikator gemessen
{
  subject: zielGuid,
  predicate: 'is-measured-by', 
  object: indikatorGuid
}
```

**Zielwerte (Objectives)**:
- Separate Container vom Typ `objective`
- `wantedValues`: Array von [Jahr, Zielwert]-Tupeln
- Relation `is-objective-for` zum Indikator

### Indikator ‚Üî Ma√ünahmen  
**Relation**: `contributes-to`
```typescript
// Ma√ünahme tr√§gt zu Indikator bei
{
  subject: ma√ünahmeGuid,
  predicate: 'contributes-to',
  object: indikatorGuid  
}
```

**Wirkungen (Effects)**:
- Container vom Typ `effect` 
- `achievedValues`: Erreichte Werte
- `plannedValues`: Geplante Wirkung
- Hierarchisch unter Ma√ünahmen (`is-part-of-measure`)

## üìä Berechnungslogik

### Chart-Darstellung
1. **Basis-Trend**: Historische Werte als Linie
2. **Zielwerte**: Separate Linie f√ºr gew√ºnschte Entwicklung
3. **Ma√ünahmenwirkungen**: 
   - Gestapelte Bereiche nach Status
   - Gr√ºn: Umgesetzte Wirkung (`status.done`)
   - Orange: In Umsetzung (`status.in_implementation`)
   - Rot: Geplant (`status.idea`)

### Aggregations-Regeln
```typescript
// Zielwerte summieren sich
objectives = findLeafObjectives(relatedContainers)
  .flatMap(({payload}) => payload.wantedValues)
  .reduce((acc, [year, value]) => {
    // Summierung bei gleichem Jahr
    return groupIndex > -1 
      ? [...acc.slice(0, groupIndex), [year, value + acc[groupIndex][1]], ...acc.slice(groupIndex + 1)]
      : [...acc, [year, value]];
  }, []);
```

## üöß Identifizierte UX-Probleme

### Aus Meeting-Analyse

#### 1. Navigations-Komplexit√§t
- **Problem**: "Navigation zu Indikatoren noch zu verschachtelt"
- **Auswirkung**: Kontext geht verloren bei Ziel-Indikator-Verkn√ºpfung
- **Workflow**: Zu viele Schritte f√ºr einfache Aufgaben

#### 2. Bearbeitungsbeschr√§nkungen
- **Problem**: "Benutzer k√∂nnen nur Basisdaten aktualisieren"
- **Einschr√§nkung**: Keine direkte Bearbeitung von Zielwerten in Zielen
- **Workaround**: Umweg √ºber Programme erforderlich

#### 3. Filter-Probleme
- **Problem**: "Filtereinstellungen zu dumm" bei "gew√ºnschte Entwicklung"
- **Auswirkung**: Nicht hilfreiche Vorauswahl
- **Bedarf**: Intelligentere Kontext-Filter

#### 4. Zielwert-Berechnungen
- **Problem**: "Immer Differenz zum aktuellen Prognose angeben"
- **Erw√ºnscht**: Absolute Zielwerte direkt eingeben
- **Herausforderung**: Wissenschaftlich korrekte Berechnungsmodelle

#### 5. Katalog-Usability  
- **Problem**: "Suche nicht sinnvoll" im Indikator-Katalog
- **Grund**: Nutzer kennen meist schon ben√∂tigte Indikatoren
- **Verbesserung**: √úberschriften und "Neue oben" Sortierung

## üéØ Nutzungsszenarien

### 1. Indikator erstellen (Setzkasten-Modus)
```typescript
// Workflow f√ºr neue Indikatoren
1. Indikator anlegen (Typ, Einheit, Kategorien)
2. Basisdaten eintragen (historicalValues)
3. Zielwerte definieren (Objective erstellen)
4. Mit Strategie verkn√ºpfen (is-measured-by)
```

### 2. Wirkungserfassung
```typescript
// Ma√ünahmen-Wirkung dokumentieren
1. Effect-Container erstellen
2. Geplante/Erreichte Werte eintragen
3. Mit Ma√ünahme verkn√ºpfen (is-part-of-measure)
4. Mit Indikator verkn√ºpfen (contributes-to)
```

### 3. Monitoring & Controlling
```typescript
// Regelm√§√üige Bewertung
1. Ist-Daten aktualisieren (historicalValues)
2. Zielabweichung analysieren (Chart)
3. Ma√ünahmen-Performance bewerten
4. Steuerungsma√ünahmen ableiten
```

## üîß Technische Implementation

### Datenbank-Struktur
```sql
-- Indikator-spezifische Abfragen
SELECT DISTINCT(c.*)
FROM container c
JOIN container_relation cr ON c.guid = cr.object
  AND cr.predicate IN ('is-measured-by', 'is-objective-for')
  AND cr.valid_currently
  AND NOT cr.deleted
```

### State Management
```typescript
// Svelte Stores f√ºr Indikator-Daten
let historicalValuesByYear = $derived(new Map(container.payload.historicalValues));
let objectives = $derived.by(() => {
  return findLeafObjectives(relatedContainers.filter(isObjectiveContainer))
    .flatMap(({payload}) => payload.wantedValues)
    // Aggregationslogik
});
```

## üé® Design-Patterns

### Editable Components
- Konsistente `editable`-Props f√ºr Bearbeitungsmodus
- Ability-basierte Berechtigungspr√ºfung
- Bindable Props f√ºr Zwei-Wege-Datenbindung

### Chart-Visualisierung
- Observable Plot f√ºr moderne Datenvisualisierung
- Reaktive Berechnungen mit Svelte 5 `$derived`
- Status-basierte Farbkodierung f√ºr √úbersichtlichkeit

### Container-Relations
- Typisierte Pr√§dikat-Konstanten
- Hierarchische Traversierung (Ancestors/Descendants)
- Position-basierte Sortierung

## üìã Verbesserungspotentiale

### Kurzfristig
1. **Direkte Zielwert-Bearbeitung** in Indikator-Ansicht
2. **Intelligente Filter** bei Ziel-Indikator-Verkn√ºpfung  
3. **Kontextuelle Navigation** ohne Seitenwechsel
4. **Absolute Zielwerte** statt nur Differenzen

### Mittelfristig  
1. **Indikator-Templates** f√ºr h√§ufige Kennzahlen
2. **Batch-Import** f√ºr historische Daten
3. **Automatisierte Berechnungen** f√ºr komplexe Indikatoren
4. **Dashboard-Widgets** f√ºr Executive Summary

### Langfristig
1. **KI-gest√ºtzte Prognosen** basierend auf Trends
2. **Cross-Indikator-Analysen** f√ºr Wirkungsketten
3. **Real-time Datenquellen** f√ºr Live-Updates
4. **Benchmark-Vergleiche** mit anderen Organisationen

## üîç Code-Qualit√§t & Architektur

### St√§rken
- ‚úÖ Typsichere Zod-Schemas f√ºr Datenvalidierung
- ‚úÖ Modulare Komponentenarchitektur  
- ‚úÖ Konsistente Container-Abstraktion
- ‚úÖ Reaktive State-Management mit Svelte 5

### Verbesserungsbedarf
- ‚ö†Ô∏è Komplexe Aggregations-Logik in Components
- ‚ö†Ô∏è Fehlende Abstraktions-Layer f√ºr Berechnungen
- ‚ö†Ô∏è Tight Coupling zwischen Chart und Business-Logic
- ‚ö†Ô∏è Unvollst√§ndige Test-Abdeckung f√ºr Beziehungslogik

---

**Fazit:** Die Indikator-Funktionalit√§t zeigt eine solide technische Architektur, hat aber UX-seitig Optimierungsbedarf bei Navigation und Workflow-Effizienz. Die Container-basierte Struktur bietet Flexibilit√§t, erfordert aber bessere Abstraktionen f√ºr komplexe Berechnungen.